<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>RingServer &mdash; UPRI EarthquakeHub 0.1 documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="_static/jquery.js?v=5d32c60e"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="_static/documentation_options.js?v=2709fde1"></script>
        <script src="_static/doctools.js?v=888ff710"></script>
        <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Slink2Dali" href="slink2dali.html" />
    <link rel="prev" title="sender-backend" href="sender-backend/overview.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            UPRI EarthquakeHub
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Tutorial</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="connect-to-rshake.html">How to Connect to Your Raspberry Shake via SSH</a></li>
<li class="toctree-l1"><a class="reference internal" href="installing-rshake-client.html">Installing EarthquakeHub Client on Raspberry Shake</a></li>
<li class="toctree-l1"><a class="reference internal" href="sending-data-to-ehub-network.html">Sending Data to EarthquakeHub Network</a></li>
<li class="toctree-l1"><a class="reference internal" href="fdsnws.html">How to Use FDSNWS to Download Ground Motion Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="intro-to-seiscomp.html">Introduction To SeisComp</a></li>
<li class="toctree-l1"><a class="reference internal" href="dev-guide-contributing.html">Developer Guide: Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="docker-cheatsheet.html">Developer Guide: Docker Cheatsheet</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Documentation</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="system-overview.html">System Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="ehub-commons.html">earthquake-hub-commons</a></li>
<li class="toctree-l1"><a class="reference internal" href="ehub-backend/overview.html">earthquake-hub-backend</a></li>
<li class="toctree-l1"><a class="reference internal" href="sender-backend/overview.html">sender-backend</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">RingServer</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#background">Background</a></li>
<li class="toctree-l2"><a class="reference internal" href="#what-it-does">What It Does</a></li>
<li class="toctree-l2"><a class="reference internal" href="#how-it-works">How It Works</a></li>
<li class="toctree-l2"><a class="reference internal" href="#changes">Changes</a></li>
<li class="toctree-l2"><a class="reference internal" href="#contributing-md">CONTRIBUTING.md</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="slink2dali.html">Slink2Dali</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">UPRI EarthquakeHub</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">RingServer</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/ringserver.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="ringserver">
<h1>RingServer<a class="headerlink" href="#ringserver" title="Link to this heading"></a></h1>
<p>This documentation aims to introduce the application of RingServer in the earthquake-hub citizen science network. See the <a class="reference external" href="https://alyssapatricia.github.io/ui/system-overview.html">system overview here</a>. This is a fork of <a class="reference external" href="https://github.com/EarthScope/ringserver">EarthScope/RingServer</a>. See their <a class="reference external" href="https://github.com/EarthScope/ringserver/blob/main/doc/ringserver.md">original documentation here</a>.</p>
<section id="background">
<h2>Background<a class="headerlink" href="#background" title="Link to this heading"></a></h2>
<p>There are various application-level communication protocols used in seismological data transmission, such are the SeedLink and DataLink protocols. The main goal of such protocols is to provide communication rules to transfer time series data from a source (such as file-archives or real-time digital sensors) towards a destination (such as a processing software or a data server).</p>
<p>The <a class="reference external" href="https://www.seiscomp.de/seiscomp3/doc/applications/seedlink.html">SeedLink</a> and <a class="reference external" href="https://seiscode.iris.washington.edu/svn/orb2ringserver/tags/release-1.0/libdali/doc/DataLink.protocol">DataLink</a> protocols both follow server-client paradigm. However there is a clear distinction in that the SeedLink protocol is a one-way stream communication from the server to the client. That is, the client initiates connection, requests a specific stream, and receives real-time or archived data stream. On the other hand, DataLink protocol can facilitate streaming of data from either direction: client to server, or server to client. That means, after initiating a connection, a client can negotiate a stream it wants, and either receive that data stream or send that data stream (given that this client has a source of data). (add connection diagram here for SeedLink and DataLink server, showing that a client in DataLink can be on both side, sender and receiver).</p>
<p>RingServer is one example of a server that utilizes the DataLink protocol as a server of time-series data. On the other hand, slink2dali and dalitool are examples of DataLink clients.</p>
</section>
<section id="what-it-does">
<h2>What It Does<a class="headerlink" href="#what-it-does" title="Link to this heading"></a></h2>
<p>A RingServer utilizes a given communication protocol to take in time-series data, write it on a ring buffer, and serve that data (or diagnostics of such data) towards the clients. It can perform these via SeedLink, DataLink, or HTTP (WebSocket) protocols.</p>
</section>
<section id="how-it-works">
<h2>How It Works<a class="headerlink" href="#how-it-works" title="Link to this heading"></a></h2>
<ol class="arabic simple">
<li><p>Running the program will start the main thread called ListenThread which listens on a socket waiting for a TCP client to connect.</p></li>
<li><p>Each new connection is handled on a new thread called ClientThread where the responses to the requests or commands from the client are handled mostly by that new thread. There are three types of clients, one for each protocol: DataLink, SeedLink, and HTTP.</p></li>
<li><p>In the case that a client sends a command to write a packet via the DataLink protocol, the execution will call <code class="docutils literal notranslate"><span class="pre">HandleWrite()</span></code> where the command message and the packet itself will undergo some checks before being written into the ring buffer via the <code class="docutils literal notranslate"><span class="pre">RingWrite()</span></code> function.</p></li>
</ol>
<p>To have a better grasp of how this works, it’s important to understand the data structure used (ring buffer) and how it is used in this application.</p>
<p>In particular, the ring buffer is chosen as the data structure in which incoming packets are to be stored. In the context of our use case, it suffices to think of it simply as an array where the end wraps around to the beginning, creating a circular structure. This is such that when we write data into this array and reach the end, we then start overwriting what had been previously written on the beginning of the array.  This can be achieved via modulo addressing, meaning given an index value that is sequentially incremented to access the array values, when this value exceeds the length of the array, using modulo addressing would instead result for the index value to return to the beginning.</p>
<p>We can see how this results to a desirable property as a temporary receptacle (buffer) for non-stop data streams: the ring structure can be given a size that wouldn’t grow over time as we write more data due to the built-in feature of overwriting old data.</p>
<p><img alt="image" src="https://github.com/UPRI-earthquake/upri-earthquake.github.io/assets/47804913/8100756f-3713-4c3c-a6e6-c9fca4ee453f" /></p>
<p>Lastly, this ring is treated as a shared memory between threads who write into and read from it. A connection from a client corresponds to a single thread, and a single thread can write multiple packets into the ring buffer. In particular, the data in the ring buffer is organized into streams, identified by a unique <code class="docutils literal notranslate"><span class="pre">streamid</span></code> with the format NET_STAT_LOC_CHANNEL. Each stream represents a time-series data recording of a single axis of motion from a station belonging to a network. To represent a stream of data within the ring buffer, a linked-list data structure is used. Each value in the linked-list points to the location in the ring buffer where the next data point of that specific stream is stored.</p>
</section>
<section id="changes">
<h2>Changes<a class="headerlink" href="#changes" title="Link to this heading"></a></h2>
<ol class="arabic">
<li><p><strong>Authorization</strong></p>
<p>Being able to control which clients can connect to a server is a useful feature in server management. More so when you allow clients to write data into your server, it is necessary to discriminate among clients based on whether they have write permissions or not. Originally, RingServer can discriminate client connections via manually written IP addresses in the server configuration file (see original <code class="docutils literal notranslate"><span class="pre">TrustedIP</span></code> configuration on original documentation). However, in citizen science application, there is no way to identify user IP address pre-connection since IP addresses are often dynamic and hidden behind Network Address Translation (NAT).</p>
<p>To solve this problem we used JSON web tokens (JWT) and an [external Authentication API](link to earthquake-hub-backend), to identify whether a client requesting to write data into the RingServer has permission or not. The way this works is:</p>
<ol class="arabic">
<li><p>We added the AUTHORIZATION command in the DataLink protocol, with the following format:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>AUTHORIZATION<span class="w"> </span>size<span class="se">\r\n</span><span class="w"> </span><span class="o">[</span>token<span class="o">]</span>
</pre></div>
</div>
<p>where token is a JWT of the client requesting WRITE permission, and size is the size of that token in bytes.</p>
</li>
<li><p>This provided token is forwarded by the RingServer to the <code class="docutils literal notranslate"><span class="pre">AuthServer</span></code>. The value of this config variable should be set in <code class="docutils literal notranslate"><span class="pre">ring.conf</span></code> and should be given the HTTPS address of the Authentication API from which the client and the RingServer are registered in.</p></li>
<li><p>In response, the AuthServer will handle the decoding and verification of the token, providing essential streamIDs and other relevant information associated with the token. Subsequently, the RingServer will designate the client connection as a write-authorized connection, specifically granting write permissions on the mentioned streamIDs.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>/*<span class="w"> </span>Response<span class="w"> </span>schema<span class="w"> </span>of<span class="w"> </span>AuthServer,<span class="w"> </span>received<span class="w"> </span>by<span class="w"> </span>RingServer<span class="w"> </span>*/
<span class="o">{</span>
<span class="w">  </span>status:<span class="w"> </span>responseCodes.INBEHALF_VERIFICATION_SUCCESS,
<span class="w">  </span>message:<span class="w"> </span><span class="s1">&#39;Sensor is a valid streamer&#39;</span>,
<span class="w">  </span>sensorInfo:<span class="w"> </span><span class="o">{</span>
<span class="w">    </span>username:<span class="w"> </span>decodedToken.username,
<span class="w">    </span>role:<span class="w"> </span>decodedToken.role,
<span class="w">    </span>streamIds:<span class="w"> </span>sensorStreamIds,<span class="w">   </span>//<span class="w"> </span>based<span class="w"> </span>on<span class="w"> </span>username<span class="err">&#39;</span>s<span class="w"> </span>registered<span class="w"> </span>WRITE<span class="w"> </span>permissions
<span class="w">    </span>tokenExp:<span class="w"> </span>decodedToken.exp,
<span class="w">  </span><span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
</li>
<li><p>Once authorized, the client gains the ability to successfully execute WRITE commands on the RingServer, specifically limited to the assigned streamIDs. In the event that the client lacks authorization, the connection will be closed. Additionally, if an authorized client attempts to write on streamIDs other than those with granted permissions, the RingServer will drop the packets.</p>
<p>SHOW FLOW DIAGRAM containing sensor, ringserver, authserver, and their messages.</p>
</li>
</ol>
<p>This approach requires clients to register beforehand if they want to be allowed write access into the RingServer. Such is a service provided by the Authentication API (AuthServer) which can be run as an external HTTPS server that can provide tokens for any registered client and can verify tokens for any <em>registered</em> RingServer. In the context of the earthquake-hub citizen science network, UPRI is hosting this Authentication API.</p>
<p>RingServer’s requesting token verification in behalf of a client should themselves also be registered through the Authentication API. This is done so as to maintain that all nodes (client or server) within the citizen science network are registered users that are all managed within the central Authentication Server.</p>
</li>
<li><p><strong>Redundant Connections</strong></p>
<p>The dual nature of a DataLink connection allows for more complex network structures. Specifically in the citizen science network, a client can choose to send data to multiple publicly available RingServer’s which themselves can also forward their data to other RingServer’s. In such a scenario, a redundant connection is possible if a source of data establishes a direct and an indirect connection such as shown in [the diagram](link to diagram). Such a redundant connection is actually tolerated so as to improve network data resiliency and to allow more localized event detection(footnote: In the context of data processing softwares, a RingServer receiving data from a client geographically closer to it than another RingServer should be able to more quickly provide this data to a processor as compared to the other RingServer).</p>
<p>A problem that will arise from allowing redundant connections is that the RingServer at the last receiving end will receive packets from the same source once for every connection. Hence, it should be able to identify duplicate packets for a given stream and perform necessary action. In this case, we decided that it is simplest to just drop the packets (or not proceed on writing them into the ring and just move to the next available packet) so as to avoid having duplicate packets written on the ring.</p>
<p>To do this, a function <code class="docutils literal notranslate"><span class="pre">CheckIfDuplicate()</span></code> was created to act as a filter on new packets, checking whether the packet is duplicate or not. This function is called before <code class="docutils literal notranslate"><span class="pre">RingWrite()</span></code>. The only basis used on deciding whether to write the new packet or not is by checking whether data <em>start-time of the packe</em>t  is later or equal to the <strong><strong><strong>end-time of the latest written packet</strong></strong></strong> in the stream that the packet belongs to (footnote: a packet contains time-series data for a given <em>duration</em> of time, hence it has a start-time and an end-time). This is a very simplistic approach and might require further improvements if need be; however, this solution can be used in this application since a ******************packet’s start-time and end-time both depends on the source data packet, i.e. a miniseed packet. That means that all packets coming from a single source and received on each different connection will have start and end times that are based on the same time source, meaning it is plausible to perform comparison between them and use this to decide time-ordering of the packets(footnote: one special case is that identical packets shall also have identical start and end times and hence can be concluded on the receiving end to be duplicates).</p>
<p>It should be mentioned that similar to the original RingServer, no packet re-ordering is performed in this fork. The packets that are coming are all received and written in the order they are received, with the difference that now we’re dropping the packet if it fails the duplicate checking.</p>
</li>
<li><p><strong>Server-Sent-Events (SSE) Endpoints</strong></p>
<p>Real-time monitoring of data and connection status is a useful feature in programs like the RingServer. The original implementation provided the <code class="docutils literal notranslate"><span class="pre">/streams</span></code> and <code class="docutils literal notranslate"><span class="pre">/connections</span></code> HTTP endpoints to serve stream data time ranges on the ring buffer and client connection diagnostics, respectively. These are available on a per-request basis, and hence if one wanted to perform real-time monitoring with these information, the simplest approach would be to perform polling on these endpoints.</p>
<p>However, in our application, it is necessary that the consumer of these status updates should not be the one triggering these requests. Moreover, we require that this information be served in JSON format. To address these requirements, we have decided to implement Server-Sent Events (SSE) by adding additional endpoints, namely <code class="docutils literal notranslate"><span class="pre">/sse-streams</span></code> and <code class="docutils literal notranslate"><span class="pre">/sse-connections</span></code>. These endpoints will serve the required information in JSON format, and the RingServer will push updates to the clients at a fixed rate. SSE functions similarly to a WebSocket connection, but it differs in that it sends data only in one direction: from the server to the client.</p>
<p>The following are example messages for each of the SSE endpoint.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>event:<span class="w"> </span>ringserver-streamids-status<span class="se">\n</span>
data:
<span class="o">{</span>
<span class="w">    </span><span class="s2">&quot;stream_ids&quot;</span>:<span class="w"> </span><span class="o">[</span>
<span class="w">    </span><span class="o">{</span>
<span class="w">        </span><span class="s2">&quot;stream_id&quot;</span>:<span class="s2">&quot;AM_RE722_00_EHZ/MSEED&quot;</span>,
<span class="w">        </span><span class="s2">&quot;earliest_data_start_time&quot;</span>:<span class="s2">&quot;2023-06-27T11:30:51.183000Z&quot;</span>,
<span class="w">        </span><span class="s2">&quot;latest_data_end_time&quot;</span>:<span class="s2">&quot;2023-06-27T12:16:40.493000Z&quot;</span>
<span class="w">    </span><span class="o">}</span>,
<span class="w">    </span><span class="o">{</span>
<span class="w">        </span><span class="s2">&quot;stream_id&quot;</span>:<span class="s2">&quot;GE_TOLI2__BHE/MSEED&quot;</span>,
<span class="w">        </span><span class="s2">&quot;earliest_data_start_time&quot;</span>:<span class="s2">&quot;2023-05-30T11:21:37.069538Z&quot;</span>,
<span class="w">        </span><span class="s2">&quot;latest_data_end_time&quot;</span>:<span class="s2">&quot;2023-06-09T10:15:00.969538Z&quot;</span>
<span class="w">    </span><span class="o">}]</span>,
<span class="w">   </span><span class="s2">&quot;current_time&quot;</span>:<span class="w"> </span><span class="s2">&quot;2023-07-06 08:19:20.833048&quot;</span>
<span class="w"> </span><span class="o">}</span>
<span class="w"> </span><span class="se">\n\n</span>
</pre></div>
</div>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>event:<span class="w"> </span>ringserver-connections-status<span class="se">\n</span>
data:
<span class="o">{</span>
<span class="w">    </span><span class="s2">&quot;connections&quot;</span>:<span class="w"> </span><span class="o">[</span>
<span class="w">    </span><span class="o">{</span>
<span class="w">        </span><span class="s2">&quot;protocol&quot;</span>:<span class="w"> </span><span class="s2">&quot;Unknown&quot;</span>,
<span class="w">        </span><span class="s2">&quot;connection_time&quot;</span>:<span class="w"> </span><span class="s2">&quot;2023-07-06 08:19:20.733105&quot;</span>,
<span class="w">        </span><span class="s2">&quot;hostname&quot;</span>:<span class="w"> </span><span class="s2">&quot;localhost&quot;</span>,
<span class="w">        </span><span class="s2">&quot;username&quot;</span>:<span class="w"> </span><span class="s2">&quot;none&quot;</span>,
<span class="w">        </span><span class="s2">&quot;role&quot;</span>:<span class="w"> </span><span class="s2">&quot;none&quot;</span>,
<span class="w">        </span><span class="s2">&quot;num_rx_packets&quot;</span>:<span class="w"> </span><span class="s2">&quot;0&quot;</span>,
<span class="w">        </span><span class="s2">&quot;rx_packets_per_sec&quot;</span>:<span class="w"> </span><span class="s2">&quot;0.0&quot;</span>,
<span class="w">        </span><span class="s2">&quot;num_rx_bytes&quot;</span>:<span class="w"> </span><span class="s2">&quot;0&quot;</span>,
<span class="w">        </span><span class="s2">&quot;rx_bytes_per_sec&quot;</span>:<span class="w"> </span><span class="s2">&quot;0.0&quot;</span>,
<span class="w">        </span><span class="s2">&quot;lag_ms&quot;</span>:<span class="w"> </span><span class="s2">&quot;0.1&quot;</span>,
<span class="w">        </span><span class="s2">&quot;stream_count&quot;</span>:<span class="w"> </span><span class="s2">&quot;0&quot;</span>,
<span class="w">        </span><span class="s2">&quot;stream_ids&quot;</span>:<span class="w"> </span><span class="o">[]</span>
<span class="w">    </span><span class="o">}</span>,
<span class="w">    </span><span class="o">{</span>
<span class="w">        </span><span class="s2">&quot;protocol&quot;</span>:<span class="w"> </span><span class="s2">&quot;DataLink&quot;</span>,
<span class="w">        </span><span class="s2">&quot;connection_time&quot;</span>:<span class="w"> </span><span class="s2">&quot;2023-07-06 08:14:23.009189&quot;</span>,
<span class="w">        </span><span class="s2">&quot;hostname&quot;</span>:<span class="w"> </span><span class="s2">&quot;localhost&quot;</span>,
<span class="w">        </span><span class="s2">&quot;username&quot;</span>:<span class="w"> </span><span class="s2">&quot;citizen&quot;</span>,
<span class="w">        </span><span class="s2">&quot;role&quot;</span>:<span class="w"> </span><span class="s2">&quot;sensor&quot;</span>,
<span class="w">        </span><span class="s2">&quot;num_rx_packets&quot;</span>:<span class="w"> </span><span class="s2">&quot;206&quot;</span>,
<span class="w">        </span><span class="s2">&quot;rx_packets_per_sec&quot;</span>:<span class="w"> </span><span class="s2">&quot;1.0&quot;</span>,
<span class="w">        </span><span class="s2">&quot;num_rx_bytes&quot;</span>:<span class="w"> </span><span class="s2">&quot;105472&quot;</span>,
<span class="w">        </span><span class="s2">&quot;rx_bytes_per_sec&quot;</span>:<span class="w"> </span><span class="s2">&quot;511.8&quot;</span>,
<span class="w">        </span><span class="s2">&quot;lag_ms&quot;</span>:<span class="w"> </span><span class="s2">&quot;0.2&quot;</span>,
<span class="w">        </span><span class="s2">&quot;stream_count&quot;</span>:<span class="w"> </span><span class="s2">&quot;16&quot;</span>,
<span class="w">        </span><span class="s2">&quot;stream_ids&quot;</span>:<span class="w"> </span><span class="o">[</span><span class="s2">&quot;GE_TOLI2_.*/MSEED&quot;</span>,<span class="s2">&quot;AM_RE722_.*/MSEED&quot;</span><span class="o">]</span>
<span class="w">    </span><span class="o">}]</span>,
<span class="w">    </span><span class="s2">&quot;current_time&quot;</span>:<span class="w"> </span><span class="s2">&quot;2023-07-06 08:19:20.833048&quot;</span>,
<span class="w">     </span><span class="s2">&quot;num_selected_connections&quot;</span>:<span class="w"> </span><span class="s2">&quot;5&quot;</span>,
<span class="w">     </span><span class="s2">&quot;total_num_connections&quot;</span>:<span class="w"> </span><span class="s2">&quot;5&quot;</span>
<span class="o">}</span>
<span class="se">\n\n</span>
</pre></div>
</div>
</li>
<li><p><strong>Docker &amp; Dependency Additions</strong></p>
<p>The features added in this fork required additional dependencies, namely <code class="docutils literal notranslate"><span class="pre">jansson</span></code> and <code class="docutils literal notranslate"><span class="pre">curl</span></code>. We have opted to include these as built-in dependencies to simplify the process of building this forked version from source. This decision also makes it easier to build it into a docker image, which is particularly beneficial for our application, as we utilize Docker Compose for both development and deployment of our microservices.</p>
</li>
</ol>
</section>
<section id="contributing-md">
<h2>CONTRIBUTING.md<a class="headerlink" href="#contributing-md" title="Link to this heading"></a></h2>
<p>This is the link for <a class="reference external" href="https://github.com/UPRI-earthquake/receiver-ringserver/blob/dev/CONTRIBUTING.md">CONTRIBUTING.md</a></p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="sender-backend/overview.html" class="btn btn-neutral float-left" title="sender-backend" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="slink2dali.html" class="btn btn-neutral float-right" title="Slink2Dali" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, UPRI.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>